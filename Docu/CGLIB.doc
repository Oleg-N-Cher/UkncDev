	О П И С А Н И Е   Б И Б Л И О Т Е К И   C G L I B  v.2.00

(C) January 1995, Tiger

  Графическая библиотека CGLIB содержит функции работы с графикой ЦП УКНЦ для
программ на языке C. Вторая версия отличается от первой  расширенным  набором
функций для работы с массивами видеоинформации, а также возможностью работы в
16ти цветах и более корректной версией функции outtext.
  Функции библиотеки не обращаются к  стандартным  меткам  C  csv$  и  cret$,
поэтому возможно их  использование  из  программ  на  ассемблере.  Вызывающая
последовательность выглядит примерно так:

	.globl	XXXXXX
	mov	argN,-(sp)
	...	..........
	mov	arg2,-(sp)
	mov	arg1,-(sp)
	call	XXXXXX
	add	#N*2,sp

Здесь  N  -  количество  аргументов  функции,  arg1..argN  -   соответственно
аргументы (нумеруются слева направо в описании функции на C), XXXXXX - первые
6 символов имени функции.
ВНИМАНИЕ! Функции изменяют содержимое R0 и R1! Содержимое других регистров не
изменяется.

	Х А Р А К Т Е Р И С Т И К А   Б И Б Л И О Т Е К И
	
  Все   графические   функции   реализованы   на   ЦП   УК-НЦ   в   связи   с
неудовлетворительно малой скоростью работы и  неудобным  интерфейсом  графики
ПЗУ. В связи с этим доступно лишь 4 цвета - соответственно экранные планы 1 и
2. Недостаточно малое количество цветов  компенсировано  введением  механизма
палитр. Физически на экране больше  4  цветов  одновременно  вы  получить  не
сможете, но вы можете "жонглировать" цветами по своему усмотрению  с  помощью
переключения палитр (см. описание функций SetPalette(), Palette()).
  Разрешение графического экрана составляет 640*288 точек, начало координат -
в левом верхнем углу экрана.
  ВНИМАНИЕ!
Для увеличения скорости работы графики  функции  не  производят  проверку  на
корректность координат, поэтому вся ответственность за  правильность  входных
данных лежит  на  программисте.  Координаты  должны  находиться  в  следующих
пределах: X : [0..639], Y : [0..287], и номер цвета в пределах [0..3]. Будьте
внимательны! Если координаты выйдут за указанные  пределы,  могут  возникнуть
неприятные сюрпризы, как то: в лучшем случае - белиберда на экране, в  худшем
- затертые ОЗУ ЦП и системная область, и, как следствие, зависание машины.
  Сравнительный анализ показал, что  скорость  работы  некоторых  функций,  в
частности, вывод точки  и  закрашенного  прямоугольника,  превышает  скорость
работы аналогичных  ПЗУшных  функций  в  1,5-2  раза.  Функция  вывода  линии
основана на алгоритме Люка,  и  ее  скорость  приблизительно  равна  скорости
ПЗУшной подпрограммы вывода линии.
  Функции работы с областями изображений имеют некоторую специфику работы:
область может начинаться только со столбца, совпадающего с началом 
знакоместа, иначе говоря, номер которого кратен 8. Скорость работы функций 
копирования         и         перемещения         составляет         примерно
175000 (сто семьдесят пять тысяч) точек/с.

	И С П О Л Ь З О В А Н И Е   Б И Б Л И О Т Е К И

  Для использования библиотеки в программах на языке  C  достаточно  включить
в компилируемую программу файл graph.h  следующей  директивой  препроцессора:
	
	#include <graph.h>

и при компоновке выполняемого  модуля  указать  в  списке  объектных  модулей
файл cglib.obj.

	О П И С А Н И Е   Ф У Н К Ц И Й   Б И Б Л И О Т Е К И

  В описании используются следующие термины:
текущая точка -   последняя обработанная функциями графики точка;
логический цвет - номер позиции палитры, содержащей номер физического
		  цвета;
физический цвет - номер цвета из таблицы отображаемых в УКНЦ цветов;
палитра -         таблица соответствий физических цветов логическим цветам.

int InitGraph()
	
	Функция инициализирует графический режим монитора и упорядочивает 
	таблицу видеострок. Вызывается всякий раз при переходе к работе с 
	графикой.

int CloseGraph()
	
	Функция отключает графический режим монитора и переходит обратно в 
	текстовый режим.

int ClearDevice()
	
	Функция очищает 1 и 2 экранные планы.

int SetLineColor(int n)
	
	Функция устанавливает цвет вывода линий, прямоугольников и 
	закрашенных прямоугольников (0<=n<=3).

int SetFillColor(int n)
	
	Функция устанавливает цвет заливки областей по FloodFill().
	0<=n<=3.

int Palette(int n)

	Функция устанавливает палитру из стандартного набора. В стандартном
	наборе имеется 4 палитры, соответствие логического цвета
	и физического цвета приведено ниже. 0<=n<=3.
	Стандартные палитры:
	Палитра 0:	0 -- черный
			1 -- зеленый
			2 -- красный
			3 -- желтый		
	Палитра 1:	0 -- синий
			1 -- голубой
			2 -- фиолетовый
			3 -- белый
	Палитра 2:	0 -- черный
			1 -- темно-зеленый
			2 -- темно-красный
			3 -- коричневый
	Палитра 3:	0 -- темно-синий
			1 -- темно-голубой (серый)
			2 -- темно-фиолетовый
			3 -- бледно-белый

int SetPalette(int c0, c1, c2, c3)

	Функция позволяет создавать произвольную палитру. Числа c0,c1,c2,c3
	представляют собой последовательность физических номеров в палитре,
	при этом 0<=cN<=15. c0 - номер физ.цвета с лог.номером 0, c1 - номер
	физ.цвета с лог.номером 1 и т.д. Соответствие физ.номеров цветам:
			0 -- черный
			1 -- темно-синий
			2 -- темно-зеленый
			3 -- серый
			4 -- темно-красный
			5 -- темно-фиолетовый
			6 -- коричневый
			7 -- бледно-белый
			8 -- черный
			9 -- синий
			10-- зеленый
			11-- голубой
			12-- красный
			13-- фиолетовый
			14-- желтый
			15-- белый

int PutPixel(int x,y,color)
	
	Функция высвечивает точку с абсолютными координатами (x,y) цветом
	color (0<=color<=3).

int GetPixel(int x,y)
	
	Функция возвращает логический цвет точки с абсолютными координатами
	(x,y).

int HLine(int x1,x2,y)
	
	Функция рисует горизонтальный отрезок из точки (x1,y) в точку (x2,y)
	цветом, установленным SetLineColor(). ВНИМАНИЕ! x1 должно быть меньше
	x2!

int VLine(int y1,y2,x)
	
	Функция рисует вертикальный отрезок из точки (x,y1) в точку (x,y2)
	цветом, установленным SetLineColor(). ВНИМАНИЕ! y1 должно быть меньше
	y2!

int Line(int x1,y1,x2,y2)
	
	Функция рисует произвольный отрезок из точки (x1,y1) в точку (x2,y2)
	цветом, установленным SetLineColor(). Если заведомо известно, что
	отрезок будет вертикальным или горизонтальным, пользуйтесь более
	быстрыми HLine() и VLine().

int HLineTo(int x)

	Функция рисует горизонтальный отрезок из текущей точки в точку с
	абсциссой x цветом, установленным SetLineColor().

int VLineTo(int y)
	
	Функция рисует вертикальный отрезок из текущей точки в точку с
	ординатой y цветом, установленным SetLineColor().

int LineTo(int x,y)
	
	Функция рисует произвольный отрезок из текущей точки в точку с
	абсолютными координатами (x,y) цветом, установленным SetLineColor().

int HLineRel(int dx)

	Функция работает аналогично HLineTo(), за исключением того, что dx
	является не абсолютной абсциссой, а смещением относительно абсциссы
	текущей точки.

int VLineRel(int dy)
	
	Функция работает аналогично VLineTo(), dy - смещение (см. HLineTo()).

int LineRel(int dx,dy)

	Функция работает аналогично LineTo(), за исключением того, что dx и 
	dy являются смещениями относительно соответственно абсциссы и 
	ординаты текущей точки.

int MoveTo(int x,y)

	Функция устанавливает координаты текущей точки равными (x,y).

int MoveRel(int dx,dy)

	Функция смещает текущую точку на dx по горизонтали и на dy по 
	вертикали.

int Rectangle(int x1,y1,x2,y2)

	Функция рисует прямоугольник с левой нижней вершиной (x1,y1) и правой
	верхней (x2,y2) цветом, установленным SetLineColor().

int Box(int x1,y1,x2,y2)

	Функция рисует закрашенный прямоугольник с левой нижней вершиной 
	(x1,y1) и правой верхней (x2,y2) цветом, установленным 
	SetLineColor().

int FloodFill(int x,y)
	
	Функция заливает произвольную замкнутую область цветом, 
	установленныи по SetFillColor(); цвет границы области принимается 
	равным текущему цвету линий.

int CopyImage(int x1,y1,length,height,xd,yd,mode)

	Функция копирует часть экрана с левым верхним углом в (x1*8,y1)
	длиной length*8 точек и высотой height точек в область с левым
	верхним углом в (xd*8,yd). Параметр mode определяет тип копирования
	и может принимать следующие значения:
		0 - копирование с затиранием (MOV);
		1 - копирование с наложением (OR);
		2 - копирование по xor (XOR);
		3 - копирование с инвертированием (COM).
	В скобках приведены константы модуля graph.h, соответствующие 
	указанным режимам.

int InvImage(int x,y,length,height)

	Функция инвертирует часть экрана с левым верхним углом (x,y)
	длиной length*8 точек и высотой height точек.

int MoveImage(int x1,y1,length,height,xd,yd,mode)

	Функция действует аналогично CopyImage(), за исключением того, что 
	копируемая область после копирования стирается.

int GetImage(int x1,y1,length,height, char *buf)

	Функция считывает с экрана область (параметры см. CopyImage()) в 
	буфер buf. Буфер buf должен иметь размер, определяемый функцией
	ImageSize().

int PutImage(int x,y, char *buf, int mode)

	Функция помещает считанную область из памяти на экран, начиная
	с позиции (x*8,y). Буфер buf должен быть заполнен только с помощью
	GetImage()!

unsigned int ImageSize(int length,height)

	Функция определяет размер памяти в байтах, необходимый для считывания
	области экрана длиной length*8 и высотой height.

int HRevImage(char *buf)
	
	Функция переворачивает область экрана, считанную в буфер buf, "вверх
	ногами".

int VRevImage(char *buf)
	
	Функция получает "зеркальное отображение" области экрана в буфере
	buf.

int SaveImage(char *buf)
	
	Функция записывает буфер buf в "скрытую" область экранной памяти,
	экономя тем самым память ЦП. buf не должен занимать больше, чем 8
	КБайт.
	ВНИМАНИЕ! Нельзя хранить в скрытой области более 1 буфера!
	ПОМНИТЕ! Скрытая область очищается по ClearDevice()!

int RestImage(char *buf)
	
	Функция считывает содержимое скрытой области экрана в буфер buf.

int OutText(int x,y, char *str)

	Функция выводит текст строки str, начиная с позиции (x,y) цветом,
	установленным по SetLineColor().

int SetTextStyle(int scale, int direction)
	
	Функция устанавливает масштаб выводимого шрифта и егь направление.
	Параметр scale задает масштаб и принимает следующие значения:
	0 - буква в 4 раза меньше;
	1 - буква в 2 раза меньше;
	2 - нормальный размер буквы;
	3 - буква в 2 раза больше;
	4 - буква в 4 раза больше;
	5 - буква в 8 раз больше;
	6 - буква в 16 раз больше.
	Параметр direction задает направление вывода текста и принимает 
	следующие значения:
	0 - горизонтально, слева направо;
	1 - вертикально,сверху вниз;
	2 - горизонтально, вверх ногами, справа налево;
	3 - вертикально, снизу вверх;
	4 - отключение вывода текста.

	И Н Ф О Р М А Ц И Я   О   Р А З Р А Б О Т Ч И К Е

Библиотека написана на ассемблере с использованием компилятора Macro 5.00.
(C) January 1995, Tiger. Тел. в Москве: 376-84-01 (с 21.00 до 22.00), Денис.

	И Н Ф О Р М А Ц И Я   О Б   О Ш И Б К А Х

Версия 2.00:

1) Функция HLine() ошибочно работает, если расстояние между началом и концом
   выводимого отрезка меньше 8. Соответственно работают с ошибкой все
   функции, работающие через HLine(): HLineTo(), HlineRel(), Box() и
   Rectangle().

2) Функция MoveImage() при совпадении или перекрывании перемещаемой области
   и области копирования неверно воспроизводит цвета.

3) При выполнении функции OutText() с 16-кратныи увеличением не 
   выполняются операции поворота выводимого текста.

4) RestImage() может повесить машину, если в скрытой области информация
   записана не по SaveImage().

P.S.: В версии 2.01 вышеуказанные ошибки исправлены. Tiger.
